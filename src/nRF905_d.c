/*
 ============================================================================
 Name        : nRF905_d.c
 Author      : zulolo
 Version     :
 Copyright   : Your copyright notice
 Description : Hello World in C, Ansi-style
 ============================================================================
 */

#include <stdint.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <stdlib.h>
#include <signal.h>
#include <pthread.h>
#include <getopt.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <linux/types.h>
#include <linux/spi/spidev.h>
#include "nRF905_d.h"
#include "GPIOcontrol.h"

#define NRF905_DATA_FIFO_FOLDER_PATH		"/var/tmp/"
#define NRF905_DATA_FIFO_C_WR_PATH			NRF905_DATA_FIFO_FOLDER_PATH "data_fifo_c_wr_php_rd"
#define NRF905_DATA_FIFO_C_RD_PATH			NRF905_DATA_FIFO_FOLDER_PATH "data_fifo_c_rd_php_wr"
#define ARRAY_SIZE(a) 						(sizeof(a) / sizeof((a)[0]))

/* Here is the RF rule:
 * UP keep transfer carrier and hopping according to unRF_HOPPING_TABLE every 100ms in no match state which
 * could be caused by DOWN not powered up or interference (miss communication or communication error exceed certain number).
 * DOWN will keep hopping according to unRF_HOPPING_TABLE every 10ms if not match. When DOWN detected CD high, send ACK frame.
 *
 * The TX&RX address is generated by some algorithm (CRC32 0x 4C11DB7 for now, both higher 8 bites and lower 1 bit are considered.
 * So address length is 4 bytes)
 *
 */
#define NRF905_CMD_WC_MASK						0x0F
#define NRF905_CMD_WC(unWR_CFG_ByteIndex)		((unWR_CFG_ByteIndex) & NRF905_CMD_WC_MASK)
#define NRF905_CMD_RC_MASK						0x0F
#define NRF905_CMD_RC(unRD_CFG_ByteIndex)		(((unRD_CFG_ByteIndex) & NRF905_CMD_RC_MASK) | 0x10)
#define NRF905_CMD_WTP							0x20
#define NRF905_CMD_RTP							0x21
#define NRF905_CMD_WTA							0x22
#define NRF905_CMD_RTA							0x23
#define NRF905_CMD_RRP							0x24

// MSB of CH_NO will always be 0
static const uint8_t NRF905_CR_DEFAULT[] =	{0x4C, 0x08,		// F=(422.4+(0x6C<<1)/10)*1; No retransmission; +6db; NOT reduce receive power
	0x44,	// 4 bytes RX & TX address;
	0x10,
	0x10, 	// 16 bytes RX & TX package length;
	0x13,
	0xEB,
	0x8A,
	0x01,	// RX address is the CRC32 of CH_NO
	0x0F};	// 16MHz crystal; enable CRC; CRC16

static const uint16_t unRF_HOPPING_TABLE[] = {	0x884C, 0x883A, 0x8846, 0x8832, 0x884A, 0x8835,
												0x884B, 0x8837, 0x884F, 0x883E, 0x8847, 0x8838,
												0x8844, 0x8834, 0x8843, 0x8834, 0x884B, 0x8839,
												0x884D, 0x883A, 0x884E, 0x883C, 0x8832, 0x883F};

enum _nRF905PinPosInModeLevel{
	NRF905_PWR_UP_PIN_POS = 0,
	NRF905_TRX_CE_PIN_POS,
	NRF905_TX_EN_PIN_POS,
	NRF905_TX_POS_MAX
};

static const uint8_t unNRF905MODE_PIN_LEVEL[][NRF905_TX_POS_MAX] = {{GPIO_LEVEL_LOW, GPIO_LEVEL_LOW, GPIO_LEVEL_LOW},
																	{GPIO_LEVEL_HIGH, GPIO_LEVEL_LOW, GPIO_LEVEL_LOW},
																	{GPIO_LEVEL_HIGH, GPIO_LEVEL_LOW, GPIO_LEVEL_LOW},
																	{GPIO_LEVEL_HIGH, GPIO_LEVEL_HIGH, GPIO_LEVEL_LOW},
																	{GPIO_LEVEL_HIGH, GPIO_LEVEL_HIGH, GPIO_LEVEL_HIGH}};
static const char nRF905SPI_Device[] = "/dev/spidev0.0";
static uint8_t unSPI_Mode = SPI_MODE_0;
static uint8_t unSPI_Bits = 8;
static uint32_t unSPI_Speed = 5000000;
static uint16_t unSPI_Delay = 1000;
static uint8_t unNeedtoClose = 0;

void sighandler(int32_t signum, siginfo_t *info, void *ptr)
{
	unNeedtoClose = 1;
}

static int32_t nRF905TX(int32_t nRF905SPIfd, uint8_t* pTX_Frame, uint8_t unFrameLength)
{
	uint8_t* pRX_Frame;
	struct spi_ioc_transfer tSPI_Transfer;

	pRX_Frame = malloc(unFrameLength + 1);
	if (NULL == pRX_Frame){
		NRF905D_LOG_ERR("nRF905TX failed because of no RAM.");
		return (-1);
	}
	tSPI_Transfer.tx_buf = (unsigned long)pTX_Frame;
	tSPI_Transfer.rx_buf = (unsigned long)pRX_Frame;
	tSPI_Transfer.len = unFrameLength;
	tSPI_Transfer.delay_usecs = unSPI_Delay;
	tSPI_Transfer.speed_hz = unSPI_Speed;
	tSPI_Transfer.bits_per_word = unSPI_Bits;

	if (ioctl(nRF905SPIfd, SPI_IOC_MESSAGE(1), &tSPI_Transfer) < 1){
		free(pRX_Frame);
		NRF905D_LOG_ERR("can't send spi message");
		return -1;
	}
	free(pRX_Frame);
	return 0;
}

int32_t setNRF905Mode(nRF905Mode_t tNRF905Mode)
{
	if (tNRF905Mode >= NRF905_MODE_MAX)
	{
		NRF905D_LOG_ERR("tNRF905Mode error.");
		return (-1);
	}

	if (-1 == GPIOWrite(NRF905_TX_EN_PIN, unNRF905MODE_PIN_LEVEL[tNRF905Mode][NRF905_TX_EN_PIN_POS])){
		NRF905D_LOG_ERR("Write GPIO pin %u failed.", NRF905_TX_EN_PIN);
		return (-1);
	}

	if (-1 == GPIOWrite(NRF905_TRX_CE_PIN, unNRF905MODE_PIN_LEVEL[tNRF905Mode][NRF905_TRX_CE_PIN_POS])){
		NRF905D_LOG_ERR("Write GPIO pin %u failed.", NRF905_TRX_CE_PIN);
		return (-1);
	}

	if (-1 == GPIOWrite(NRF905_PWR_UP_PIN, unNRF905MODE_PIN_LEVEL[tNRF905Mode][NRF905_PWR_UP_PIN_POS])){
		NRF905D_LOG_ERR("Write GPIO pin %u failed.", NRF905_PWR_UP_PIN);
		return (-1);
	}
	usleep(1000);
	return 0;
}

static int32_t nRF905RX(int32_t nRF905SPIfd, uint8_t* pTX_Frame, uint8_t* pRX_Frame, uint8_t unFrameLength)
{
	struct spi_ioc_transfer tSPI_Transfer;

	tSPI_Transfer.tx_buf = (unsigned long)pTX_Frame;
	tSPI_Transfer.rx_buf = (unsigned long)pRX_Frame;
	tSPI_Transfer.len = unFrameLength;
	tSPI_Transfer.delay_usecs = unSPI_Delay;
	tSPI_Transfer.speed_hz = unSPI_Speed;
	tSPI_Transfer.bits_per_word = unSPI_Bits;

	if (ioctl(nRF905SPIfd, SPI_IOC_MESSAGE(1), &tSPI_Transfer) < 1){
		NRF905D_LOG_ERR("can't send spi message");
		return -1;
	}
	return 0;
}

static int32_t nRF905CR_Initial(int32_t nRF905SPIfd)
{
	uint8_t* pTXwCMD;
	uint8_t* pRXwStatus;

	if (setNRF905Mode(NRF905_MODE_STD_BY) < 0){
		NRF905D_LOG_ERR("Set nRF905 mode %d failed.", NRF905_MODE_PWR_DOWN);
		return (-1);
	}

	pTXwCMD = malloc(ARRAY_SIZE(NRF905_CR_DEFAULT) + 1);
	if (NULL == pTXwCMD){
		NRF905D_LOG_ERR("nRF905CR_Initial failed because of no TX RAM.");
		return (-1);
	}
	pTXwCMD[0] = NRF905_CMD_WC(0);
	memcpy(pTXwCMD + 1, NRF905_CR_DEFAULT, ARRAY_SIZE(NRF905_CR_DEFAULT));
	if (nRF905TX(nRF905SPIfd, pTXwCMD, ARRAY_SIZE(NRF905_CR_DEFAULT) + 1) < 0){
		free(pTXwCMD);
		NRF905D_LOG_ERR("nRF905 control register initialization failed at nRF905 TX.");
		return -1;
	}

	pRXwStatus = malloc(ARRAY_SIZE(NRF905_CR_DEFAULT) + 1);
	if (NULL == pRXwStatus){
		free(pTXwCMD);
		NRF905D_LOG_ERR("nRF905CR_Initial failed because of no RX RAM.");
		return (-1);
	}
	pTXwCMD[0] = NRF905_CMD_RC(0);
	if (nRF905RX(nRF905SPIfd, pTXwCMD, pRXwStatus, ARRAY_SIZE(NRF905_CR_DEFAULT) + 1) < 0){
		free(pTXwCMD);
		free(pRXwStatus);
		NRF905D_LOG_ERR("nRF905 control register initialization failed at nRF905 RX.");
		return -1;
	}
	if (memcmp(pRXwStatus + 1, NRF905_CR_DEFAULT, ARRAY_SIZE(NRF905_CR_DEFAULT)) != 0){
		free(pTXwCMD);
		free(pRXwStatus);
		NRF905D_LOG_ERR("nRF905 control register initialization failed at comparing CR value.");
		return -1;
	}
	free(pTXwCMD);
	free(pRXwStatus);
	return 0;
}

int32_t nRF905SpiInitial(int32_t nRF905SPIfd)
{
	/*
	 * spi mode
	 */
	if (ioctl(nRF905SPIfd, SPI_IOC_WR_MODE, &unSPI_Mode) < 0){
		NRF905D_LOG_ERR("can't set spi mode");
		return (-1);
	}

	if (ioctl(nRF905SPIfd, SPI_IOC_RD_MODE, &unSPI_Mode) < 0){
		NRF905D_LOG_ERR("can't get spi mode");
		return (-1);
	}

	/*
	 * bits per word
	 */
	if (ioctl(nRF905SPIfd, SPI_IOC_WR_BITS_PER_WORD, &unSPI_Bits) < 0){
		NRF905D_LOG_ERR("can't set bits per word");
		return (-1);
	}

	if (ioctl(nRF905SPIfd, SPI_IOC_RD_BITS_PER_WORD, &unSPI_Bits) < 0){
		NRF905D_LOG_ERR("can't get bits per word");
		return (-1);
	}

	/*
	 * max speed hz
	 */
	if (ioctl(nRF905SPIfd, SPI_IOC_WR_MAX_SPEED_HZ, &unSPI_Speed) < 0){
		NRF905D_LOG_ERR("can't set max speed hz");
		return (-1);
	}

	if (ioctl(nRF905SPIfd, SPI_IOC_RD_MAX_SPEED_HZ, &unSPI_Speed) < 0){
		NRF905D_LOG_ERR("can't get max speed hz");
		return (-1);
	}

	return 0;
}

int32_t nNRF905ExecuteTask(int32_t nRF905SPI_Fd, nRF905CommTask_t tNRF905CommTask, uint8_t* pCommPayload)
{
	// Use state machine here to control mode and hopping
	return 0;
}

typedef struct _NRF905CommThreadPara{
	int32_t nTaskReadPipe;
	int32_t nRF905SPI_Fd;
}nRF905CommThreadPara_t;

void* pNRF905Comm(void *ptr)
{
	nRF905CommTask_t tNRF905CommTask;
	nRF905CommThreadPara_t tNRF905CommThreadPara = *((nRF905CommThreadPara_t *)ptr);
	uint8_t* pCommPayload;

	while (unNeedtoClose == 0){
		if (read(tNRF905CommThreadPara.nTaskReadPipe, &tNRF905CommTask, sizeof(nRF905CommTask_t)) > 0){
			if (tNRF905CommTask.unCommByteNum > 0){
				pCommPayload = malloc(tNRF905CommTask.unCommByteNum);
				if (NULL == pCommPayload){
					NRF905D_LOG_ERR("WTF malloc fail??");
				}else{
					if (read(tNRF905CommThreadPara.nTaskReadPipe, pCommPayload, tNRF905CommTask.unCommByteNum) > 0){
						nNRF905ExecuteTask(tNRF905CommThreadPara.nRF905SPI_Fd, tNRF905CommTask, pCommPayload);
					}else{
						NRF905D_LOG_ERR("Read task communication payload from pipe error with code:%d", errno);
					}
					free(pCommPayload);
				}
			}
		}else{
			NRF905D_LOG_ERR("Read task communication type from pipe error with code:%d", errno);
		}

	}
	pthread_exit(0);
}

void* pRoutineWork(void *ptr)
{

	pthread_exit(0);
}

int32_t main(void) {
	int32_t nRF905SPI_Fd;
	nRF905CommThreadPara_t tNRF905CommThreadPara;
	int32_t nRet;
	struct sigaction tSignalAction;
	pthread_t tRoutineThread, tNRF905CommThread;
	int32_t nTaskExecPipe[2];
	int32_t nNRF905DataFIFO_C_Read, nNRF905DataFIFO_C_Write;

    tSignalAction.sa_sigaction = sighandler;
    tSignalAction.sa_flags = SA_SIGINFO;

    sigaction(SIGTERM, &tSignalAction, NULL);

	puts("!!!nRF905 Daemon start!!!"); /* prints !!!nRF905 Daemon start!!! */

	NRF905D_LOG_INFO("nRF905 Daemon start...");

	if (nInitNRF905GPIO() < 0){
		NRF905D_LOG_ERR("Initialize nRF905 GPIO failed.");
		return nDisableSPI_GPIO();
	}

	nRF905SPI_Fd = open(nRF905SPI_Device, O_RDWR);
	if (nRF905SPI_Fd < 0) {
		NRF905D_LOG_ERR("Can't open device %s.", nRF905SPI_Device);
		return nDisableSPI_GPIO();
	}

	if (nRF905SpiInitial(nRF905SPI_Fd) < 0){
		close(nRF905SPI_Fd);
		return nDisableSPI_GPIO();
	}

	if (nRF905CR_Initial(nRF905SPI_Fd) < 0){
		close(nRF905SPI_Fd);
		NRF905D_LOG_ERR("nRF905CR_Initial failed.");
		return nDisableSPI_GPIO();
	}

	// Prepare the pipe
	nRet = pipe(nTaskExecPipe);
	if(nRet < 0){
		NRF905D_LOG_ERR("Open task execution pipe failed with error:%d.", nRet);
		close(nRF905SPI_Fd);
		return nDisableSPI_GPIO();
	}

	// Start little birds
	nRet = pthread_create(&tNRF905CommThread, NULL, pNRF905Comm, nTaskExecPipe);
	if(nRet < 0){
		NRF905D_LOG_ERR("Start nRF905 communication thread failed with error:%d.", nRet);
		close(nRF905SPI_Fd);
		return nDisableSPI_GPIO();
	}

	tNRF905CommThreadPara.nRF905SPI_Fd = nRF905SPI_Fd;
	tNRF905CommThreadPara.nTaskReadPipe = nTaskExecPipe[0];
	nRet = pthread_create(&tRoutineThread, NULL, pRoutineWork, &tNRF905CommThreadPara);
	if(nRet < 0){
		NRF905D_LOG_ERR("Start routine thread failed with error:%d.", nRet);
		close(nRF905SPI_Fd);
		return nDisableSPI_GPIO();
	}

	unlink(NRF905_DATA_FIFO_C_WR_PATH);
	unlink(NRF905_DATA_FIFO_C_RD_PATH);
	nRet = mkfifo(NRF905_DATA_FIFO_C_WR_PATH, S_IRUSR| S_IWUSR);
	if (nRet < 0) {
		NRF905D_LOG_ERR("mkfifo failed with error:%d.", errno);
		close(nRF905SPI_Fd);
		return nDisableSPI_GPIO();
	}

	nRet = mkfifo(NRF905_DATA_FIFO_C_RD_PATH, S_IRUSR| S_IWUSR);
	if (nRet < 0) {
		NRF905D_LOG_ERR("mkfifo failed with error:%d.", errno);
		close(nRF905SPI_Fd);
		unlink(NRF905_DATA_FIFO_C_WR_PATH);
		return nDisableSPI_GPIO();
	}

	// in PHP NRF905_DATA_FIFO_C_RD_PATH should also be opened first
	nNRF905DataFIFO_C_Read = open(NRF905_DATA_FIFO_C_RD_PATH, O_RDONLY);
	if (nNRF905DataFIFO_C_Read < 0){
		NRF905D_LOG_ERR("Open FIFO read pipe with error:%d.", errno);
		close(nRF905SPI_Fd);
		unlink(NRF905_DATA_FIFO_C_WR_PATH);
		unlink(NRF905_DATA_FIFO_C_RD_PATH);
		return nDisableSPI_GPIO();
	}

	nNRF905DataFIFO_C_Write = open(NRF905_DATA_FIFO_C_WR_PATH, O_WRONLY);
	if (nNRF905DataFIFO_C_Write < 0){
		NRF905D_LOG_ERR("Open FIFO write pipe with error:%d.", errno);
		close(nRF905SPI_Fd);
		unlink(NRF905_DATA_FIFO_C_WR_PATH);
		unlink(NRF905_DATA_FIFO_C_RD_PATH);
		return nDisableSPI_GPIO();
	}

	// If no one open the other side of the two FIFO, and also no INT, here will never reach
	while (unNeedtoClose == 0){
		usleep(500000);
	}
	NRF905D_LOG_INFO("INT signal was received, exit.");

	pthread_join(tNRF905CommThread, NULL);
	pthread_join(tRoutineThread, NULL);

	unlink(NRF905_DATA_FIFO_C_WR_PATH);
	unlink(NRF905_DATA_FIFO_C_RD_PATH);
	close(nRF905SPI_Fd);
	return nDisableSPI_GPIO();
}
