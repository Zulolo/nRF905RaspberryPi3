/*
 ============================================================================
 Name        : nRF905_d.c
 Author      : zulolo
 Version     :
 Copyright   : Your copyright notice
 Description : Hello World in C, Ansi-style
 ============================================================================
 */

#include <stdint.h>
#include <unistd.h>
#include <stdio.h>
#include <errno.h>
#include <stdlib.h>
#include <signal.h>
#include <pthread.h>
#include <getopt.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <linux/types.h>
#include <linux/spi/spidev.h>
#include "nRF905_d.h"

#define GPIO_INPUT  						0
#define GPIO_OUTPUT 						1

#define GPIO_LEVEL_LOW  					0
#define GPIO_LEVEL_HIGH 					1

#define NRF905_TX_EN_PIN					17
#define NRF905_TRX_CE_PIN					18
#define NRF905_PWR_UP_PIN					27
#define NRF905_DATA_FIFO_FOLDER_PATH		"/var/tmp/"
#define NRF905_DATA_FIFO_C_WR_PATH			NRF905_DATA_FIFO_FOLDER_PATH "data_fifo_c_wr_php_rd"
#define NRF905_DATA_FIFO_C_RD_PATH			NRF905_DATA_FIFO_FOLDER_PATH "data_fifo_c_rd_php_wr"
#define ARRAY_SIZE(a) 						(sizeof(a) / sizeof((a)[0]))

/* Here is the RF rule:
 * UP keep transfer carrier and hopping according to unRF_HOPPING_TABLE every 100ms in no match state which
 * could be caused by DOWN not powered up or interference (miss communication or communication error exceed certain number).
 * DOWN will keep hopping according to unRF_HOPPING_TABLE every 10ms if not match. When DOWN detected CD high, send ACK frame.
 *
 * The TX&RX address is generated by some algorithm (CRC32 0x 4C11DB7 for now, both higher 8 bites and lower 1 bit are considered.
 * So address length is 4 bytes)
 *
 */
#define NRF905_CR_DEFAULT		{0x6C, \
	0x0A, \
	0x44, \
	0x10, \
	0x10, \
	0x51, \
	0xA6, \
	0x93, \
	0x37, \
	0x0F}		// F=(422.4+(0x6C<<1)/10)*2; No retransmission; +6db; NOT reduce receive power
// 4 bytes RX & TX address; 16 bytes RX & TX package length; RX address is the CRC32 of CH_NO
// 16MHz crystal; enable CRC; CRC16

static const uint16_t unRF_HOPPING_TABLE[] = {0x8A17, 0x8A83};

enum _nRF905PinPosInModeLevel{
	NRF905_PWR_UP_PIN_POS = 0,
	NRF905_TRX_CE_PIN_POS,
	NRF905_TX_EN_PIN_POS,
	NRF905_TX_POS_MAX
};

static const uint8_t unNRF905MODE_PIN_LEVEL[][NRF905_TX_POS_MAX] = {{GPIO_LEVEL_LOW, GPIO_LEVEL_LOW, GPIO_LEVEL_LOW},
													{GPIO_LEVEL_HIGH, GPIO_LEVEL_LOW, GPIO_LEVEL_LOW},
													{GPIO_LEVEL_HIGH, GPIO_LEVEL_LOW, GPIO_LEVEL_LOW},
													{GPIO_LEVEL_HIGH, GPIO_LEVEL_HIGH, GPIO_LEVEL_LOW},
													{GPIO_LEVEL_HIGH, GPIO_LEVEL_HIGH, GPIO_LEVEL_HIGH}};
static const char nRF905SPI_Device[] = "/dev/spidev0.0";
static uint8_t unSPI_Mode = SPI_MODE_0;
static uint8_t unSPI_Bits = 8;
static uint32_t unSPI_Speed = 5000000;
static uint16_t unSPI_Delay = 1000;
static uint8_t unNeedtoClose = 0;

void sighandler(int32_t signum, siginfo_t *info, void *ptr)
{
	unNeedtoClose = 1;
}


static int32_t nRF905CR_Initial(int32_t nRF905SPIfd)
{
	int32_t nRet;
	uint8_t unTx[] = NRF905_CR_DEFAULT;
	uint8_t unRx[ARRAY_SIZE(unTx)] = {0, };
	struct spi_ioc_transfer tSPI_Transfer = {
		.tx_buf = (unsigned long)unTx,
		.rx_buf = (unsigned long)unRx,
		.len = ARRAY_SIZE(unTx),
		.delay_usecs = unSPI_Delay,
		.speed_hz = unSPI_Speed,
		.bits_per_word = unSPI_Bits,
	};

	nRet = ioctl(nRF905SPIfd, SPI_IOC_MESSAGE(1), &tSPI_Transfer);
	if (nRet < 1){
		NRF905D_LOG_ERR("can't send spi message");
		return -1;
	}
	return 0;
}

static int32_t GPIOExport(int32_t pin)
{
#define BUFFER_MAX 3
	char buffer[BUFFER_MAX];
	ssize_t bytes_written;
	int32_t fd;

	fd = open("/sys/class/gpio/export", O_WRONLY);
	if (-1 == fd) {
		fprintf(stderr, "Failed to open export for writing!\n");
		return(-1);
	}

	bytes_written = snprintf(buffer, BUFFER_MAX, "%d", pin);
	write(fd, buffer, bytes_written);
	close(fd);
	return(0);
}

static int32_t GPIOUnexport(int32_t pin)
{
	char buffer[BUFFER_MAX];
	ssize_t bytes_written;
	int32_t fd;

	fd = open("/sys/class/gpio/unexport", O_WRONLY);
	if (-1 == fd) {
		fprintf(stderr, "Failed to open unexport for writing!\n");
		return(-1);
	}

	bytes_written = snprintf(buffer, BUFFER_MAX, "%d", pin);
	write(fd, buffer, bytes_written);
	close(fd);
	return(0);
}

int32_t nDisableGPIO(void)
{
	/*
	 * Disable GPIO pins
	 */
	if ((-1 == GPIOUnexport(NRF905_TX_EN_PIN)) || (-1 == GPIOUnexport(NRF905_TRX_CE_PIN)) ||
			(-1 == GPIOUnexport(NRF905_PWR_UP_PIN))){
		NRF905D_LOG_ERR("GPIO pin disable failed.");
		return (-1);
	}
	return 0;
}

static int32_t GPIODirection(int32_t pin, int32_t dir)
{
	static const char s_directions_str[]  = "in\0out";

#define DIRECTION_MAX 35
	char path[DIRECTION_MAX];
	int32_t fd;

	snprintf(path, DIRECTION_MAX, "/sys/class/gpio/gpio%d/direction", pin);
	fd = open(path, O_WRONLY);
	if (-1 == fd) {
		printf("Failed to open pin %d direction for writing!\n", pin);
		fprintf(stderr, "Failed to open gpio direction for writing!\n");
		return(-1);
	}

	if (-1 == write(fd, &s_directions_str[GPIO_INPUT == dir ? 0 : 3], GPIO_INPUT == dir ? 2 : 3)) {
		fprintf(stderr, "Failed to set direction!\n");
		return(-1);
	}

	close(fd);
	return(0);
}

int32_t nInitGPIO(void)
{
	/*
	 * Enable GPIO pins
	 */
	if ((-1 == GPIOExport(NRF905_TX_EN_PIN)) || (-1 == GPIOExport(NRF905_TRX_CE_PIN)) ||
			(-1 == GPIOExport(NRF905_PWR_UP_PIN))){
		NRF905D_LOG_ERR("GPIO pin enable failed.");
		return (-1);
	}
	usleep(100000);
	/*
	 * Set GPIO directions
	 */
	if ((-1 == GPIODirection(NRF905_TX_EN_PIN, GPIO_OUTPUT)) || (-1 == GPIODirection(NRF905_TRX_CE_PIN, GPIO_OUTPUT)) ||
			(-1 == GPIODirection(NRF905_PWR_UP_PIN, GPIO_OUTPUT))){
		NRF905D_LOG_ERR("Config GPIO pin failed.");
		return (-1);
	}
	usleep(1000);
	return 0;
}

static int32_t GPIORead(int32_t pin)
{
#define VALUE_MAX 30
	char path[VALUE_MAX];
	char value_str[3];
	int32_t fd;

	snprintf(path, VALUE_MAX, "/sys/class/gpio/gpio%d/value", pin);
	fd = open(path, O_RDONLY);
	if (-1 == fd) {
		fprintf(stderr, "Failed to open gpio value for reading!\n");
		return (-1);
	}

	if (-1 == read(fd, value_str, 3)) {
		fprintf(stderr, "Failed to read value!\n");
		return (-1);
	}

	close(fd);

	return(atoi(value_str));
}

static int32_t GPIOWrite(int32_t pin, int32_t value)
{
	static const char s_values_str[] = "01";

	char path[VALUE_MAX];
	int32_t fd;

	snprintf(path, VALUE_MAX, "/sys/class/gpio/gpio%d/value", pin);
	fd = open(path, O_WRONLY);
	if (-1 == fd) {
		fprintf(stderr, "Failed to open gpio value for writing!\n");
		return (-1);
	}

	if (1 != write(fd, &s_values_str[GPIO_LEVEL_LOW == value ? 0 : 1], 1)) {
		fprintf(stderr, "Failed to write value!\n");
		return (-1);
	}

	close(fd);
	return(0);
}

int32_t setNRF905Mode(nRF905Mode_t tNRF905Mode)
{
	if (tNRF905Mode >= NRF905_MODE_MAX)
	{
		NRF905D_LOG_ERR("tNRF905Mode error.");
		return (-1);
	}

	if (-1 == GPIOWrite(NRF905_TX_EN_PIN, unNRF905MODE_PIN_LEVEL[tNRF905Mode][NRF905_TX_EN_PIN_POS])){
		NRF905D_LOG_ERR("Write GPIO pin %u failed.", NRF905_TX_EN_PIN);
		return (-1);
	}

	if (-1 == GPIOWrite(NRF905_TRX_CE_PIN, unNRF905MODE_PIN_LEVEL[tNRF905Mode][NRF905_TRX_CE_PIN_POS])){
		NRF905D_LOG_ERR("Write GPIO pin %u failed.", NRF905_TRX_CE_PIN);
		return (-1);
	}

	if (-1 == GPIOWrite(NRF905_PWR_UP_PIN, unNRF905MODE_PIN_LEVEL[tNRF905Mode][NRF905_PWR_UP_PIN_POS])){
		NRF905D_LOG_ERR("Write GPIO pin %u failed.", NRF905_PWR_UP_PIN);
		return (-1);
	}
	usleep(1000);
	return 0;
}

int32_t nRF905SpiInitial(int32_t nRF905SPIfd)
{
	/*
	 * spi mode
	 */
	if (ioctl(nRF905SPIfd, SPI_IOC_WR_MODE, &unSPI_Mode) < 0){
		NRF905D_LOG_ERR("can't set spi mode");
		return (-1);
	}

	if (ioctl(nRF905SPIfd, SPI_IOC_RD_MODE, &unSPI_Mode) < 0){
		NRF905D_LOG_ERR("can't get spi mode");
		return (-1);
	}

	/*
	 * bits per word
	 */
	if (ioctl(nRF905SPIfd, SPI_IOC_WR_BITS_PER_WORD, &unSPI_Bits) < 0){
		NRF905D_LOG_ERR("can't set bits per word");
		return (-1);
	}

	if (ioctl(nRF905SPIfd, SPI_IOC_RD_BITS_PER_WORD, &unSPI_Bits) < 0){
		NRF905D_LOG_ERR("can't get bits per word");
		return (-1);
	}

	/*
	 * max speed hz
	 */
	if (ioctl(nRF905SPIfd, SPI_IOC_WR_MAX_SPEED_HZ, &unSPI_Speed) < 0){
		NRF905D_LOG_ERR("can't set max speed hz");
		return (-1);
	}

	if (ioctl(nRF905SPIfd, SPI_IOC_RD_MAX_SPEED_HZ, &unSPI_Speed) < 0){
		NRF905D_LOG_ERR("can't get max speed hz");
		return (-1);
	}

	return 0;
}

int32_t nNRF905ExecuteTask(int32_t nRF905SPI_Fd, nRF905CommTask_t tNRF905CommTask, uint8_t* pCommPayload)
{
	// Use state machine here to control mode and hopping
	return 0;
}

typedef struct _NRF905CommThreadPara{
	int32_t nTaskReadPipe;
	int32_t nRF905SPI_Fd;
}nRF905CommThreadPara_t;

void* pNRF905Comm(void *ptr)
{
	nRF905CommTask_t tNRF905CommTask;
	nRF905CommThreadPara_t tNRF905CommThreadPara = *((nRF905CommThreadPara_t *)ptr);
	uint8_t* pCommPayload;

	while (unNeedtoClose == 0){
		if (read(tNRF905CommThreadPara.nTaskReadPipe, &tNRF905CommTask, sizeof(nRF905CommTask_t)) > 0){
			if (tNRF905CommTask.unCommByteNum > 0){
				pCommPayload = malloc(tNRF905CommTask.unCommByteNum);
				if (NULL == pCommPayload){
					NRF905D_LOG_ERR("WTF malloc fail??");
				}else{
					if (read(tNRF905CommThreadPara.nTaskReadPipe, pCommPayload, tNRF905CommTask.unCommByteNum) > 0){
						nNRF905ExecuteTask(tNRF905CommThreadPara.nRF905SPI_Fd, tNRF905CommTask, pCommPayload);
					}else{
						NRF905D_LOG_ERR("Read task communication payload from pipe error with code:%d", errno);
					}
					free(pCommPayload);
				}
			}
		}else{
			NRF905D_LOG_ERR("Read task communication type from pipe error with code:%d", errno);
		}

	}
	pthread_exit(0);
}

void* pRoutineWork(void *ptr)
{

	pthread_exit(0);
}

int32_t main(void) {
	int32_t nRF905SPI_Fd;
	nRF905CommThreadPara_t tNRF905CommThreadPara;
	int32_t nRet;
	struct sigaction tSignalAction;
	pthread_t tRoutineThread, tNRF905CommThread;
	int32_t nTaskExecPipe[2];
	int32_t nNRF905DataFIFO_C_Read, nNRF905DataFIFO_C_Write;

    tSignalAction.sa_sigaction = sighandler;
    tSignalAction.sa_flags = SA_SIGINFO;

    sigaction(SIGTERM, &tSignalAction, NULL);

	puts("!!!nRF905 Daemon start!!!"); /* prints !!!nRF905 Daemon start!!! */

	NRF905D_LOG_INFO("nRF905 Daemon start...");

	nInitGPIO();

	if (setNRF905Mode(NRF905_MODE_PWR_DOWN) < 0){
		return nDisableGPIO();
	}

	nRF905SPI_Fd = open(nRF905SPI_Device, O_RDWR);
	if (nRF905SPI_Fd < 0) {
		NRF905D_LOG_ERR("Can't open device %s.", nRF905SPI_Device);
		return nDisableGPIO();
	}

	if (nRF905SpiInitial(nRF905SPI_Fd) < 0){
		close(nRF905SPI_Fd);
		return nDisableGPIO();
	}

	if (nRF905CR_Initial(nRF905SPI_Fd) < 0){

	}

	// Prepare the pipe
	nRet = pipe(nTaskExecPipe);
	if(nRet < 0){
		NRF905D_LOG_ERR("Open task execution pipe failed with error:%d.", nRet);
		close(nRF905SPI_Fd);
		return nDisableGPIO();
	}

	// Start little birds
	nRet = pthread_create(&tNRF905CommThread, NULL, pNRF905Comm, nTaskExecPipe);
	if(nRet < 0){
		NRF905D_LOG_ERR("Start nRF905 communication thread failed with error:%d.", nRet);
		close(nRF905SPI_Fd);
		return nDisableGPIO();
	}

	tNRF905CommThreadPara.nRF905SPI_Fd = nRF905SPI_Fd;
	tNRF905CommThreadPara.nTaskReadPipe = nTaskExecPipe[0];
	nRet = pthread_create(&tRoutineThread, NULL, pRoutineWork, &tNRF905CommThreadPara);
	if(nRet < 0){
		NRF905D_LOG_ERR("Start routine thread failed with error:%d.", nRet);
		close(nRF905SPI_Fd);
		return nDisableGPIO();
	}

	unlink(NRF905_DATA_FIFO_C_WR_PATH);
	unlink(NRF905_DATA_FIFO_C_RD_PATH);
	nRet = mkfifo(NRF905_DATA_FIFO_C_WR_PATH, S_IRUSR| S_IWUSR);
	if (nRet < 0) {
		NRF905D_LOG_ERR("mkfifo failed with error:%d.", errno);
		close(nRF905SPI_Fd);
		return nDisableGPIO();
	}

	nRet = mkfifo(NRF905_DATA_FIFO_C_RD_PATH, S_IRUSR| S_IWUSR);
	if (nRet < 0) {
		NRF905D_LOG_ERR("mkfifo failed with error:%d.", errno);
		close(nRF905SPI_Fd);
		unlink(NRF905_DATA_FIFO_C_WR_PATH);
		return nDisableGPIO();
	}

	// in PHP NRF905_DATA_FIFO_C_RD_PATH should also be opened first
	nNRF905DataFIFO_C_Read = open(NRF905_DATA_FIFO_C_RD_PATH, O_RDONLY);
	if (nNRF905DataFIFO_C_Read < 0){
		NRF905D_LOG_ERR("Open FIFO read pipe with error:%d.", errno);
		close(nRF905SPI_Fd);
		unlink(NRF905_DATA_FIFO_C_WR_PATH);
		unlink(NRF905_DATA_FIFO_C_RD_PATH);
		return nDisableGPIO();
	}

	nNRF905DataFIFO_C_Write = open(NRF905_DATA_FIFO_C_WR_PATH, O_WRONLY);
	if (nNRF905DataFIFO_C_Write < 0){
		NRF905D_LOG_ERR("Open FIFO write pipe with error:%d.", errno);
		close(nRF905SPI_Fd);
		unlink(NRF905_DATA_FIFO_C_WR_PATH);
		unlink(NRF905_DATA_FIFO_C_RD_PATH);
		return nDisableGPIO();
	}

	// If no one open the other side of the two FIFO, and also no INT, here will never reach
	while (unNeedtoClose == 0){
		usleep(500000);
	}
	NRF905D_LOG_INFO("INT signal was received, exit.");

	pthread_join(tNRF905CommThread, NULL);
	pthread_join(tRoutineThread, NULL);

	unlink(NRF905_DATA_FIFO_C_WR_PATH);
	unlink(NRF905_DATA_FIFO_C_RD_PATH);
	close(nRF905SPI_Fd);
	return nDisableGPIO();
}
